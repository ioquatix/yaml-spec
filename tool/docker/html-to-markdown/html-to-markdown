#!/usr/bin/env coffee

require 'ingy-prelude'
Turndown = require 'turndown'
Node = require 'domino/lib/Node'
wrap = require 'smartwrap'

count = 0

tag_and_class = (tag, class_)->
  (n, o)->
    n.nodeName == tag.toUpperCase() and
    n.getAttribute('class') == class_

getTexts = (node, a)->
  if node.nodeType == Node.TEXT_NODE
    a.push node._data
  else if node.nodeName == 'BR'
    a.push "\n  "
  else
    for n in node.childNodes
      getTexts n, a

getRowData = (tr)->
  a = []
  for td in tr.childNodes
    a.push _.trim(td.textContent) || ' '
  return a

reformat_para = (para)->
  text = para.replace /\ \ $/mg, '%%%'
  text = text.replace /([\s\S]+?)(?:(\.)\ (?=[A-Z])|$)/g, (x, s, e)->
    e ?= ''
    wrap(s, width: 79) + "#{e}\n"
  text = text.replace /%%%$/mg, '  '
  return text


class HtmlToMarkdown
  constructor: ->
    @turndown = new Turndown
      headingStyle: 'atx'
      preformattedCode: true
      codeBlockStyle: 'fenced'
      linkStyle: 'inlined'
      hr: '----'

    for k, v of @constructor.rules
      @turndown.addRule k, v

  convert: (html)->
    html = html.replace(/[“”]/g, '"')

    markdown = @turndown.turndown html
      .replace(/.*\n.*\n/, '')
      .replace(/^(###.*)\n\n</gm, '$1 <')
      .replace(/"""/g, "'\"'")


  @rules:
    index:
      filter: tag_and_class 'div', 'index'
      replacement: (m, n, o)->
        return "[%index%]\n"


    simplelist:
      filter: tag_and_class 'table', 'simplelist'
      replacement: (m, n, o)->
        return m unless m.match /\[\d+\]/
        return m.replace /^[\s\S]*(```\n[\s\S]+\n```\n)\s*(\S[\s\S]+?\S)\s*$/,
          (m, m1, m2)-> "#{m2}\n\n#{m1}"

    subtitle:
      filter: tag_and_class 'h2', 'subtitle'
      replacement: (m, n, o)->
        return "**#{m}**\n"

    authorgroup:
      filter: tag_and_class 'div', 'authorgroup'
      replacement: (m, n, o)->
        text = m
          .replace(/### /g, '* **')
          .replace(/\n\n</g, ' <')
          .replace(/>/g, '>**')
          .replace(/\n\n/g, "\n")
        text + "{:.authorgroup}"

    indexdiv:
      filter: tag_and_class 'div', 'indexdiv'
      replacement: (m, n, o)->
        return m.replace /### (.*)/, '**$1**'

    toc:
      filter: tag_and_class 'div', 'toc'
      replacement: (m, n, o)->
        return "[%toc%]\n"

    informaltable:
      filter: tag_and_class 'div', 'informaltable'
      replacement: (m, n, o)->
        table = ''
        for tr, i in n.getElementsByTagName 'TR'
          a = getRowData tr
          table += '| ' + a.join(' | ') + "\n"
          if i == 0
            table += '| ' + _.repeat('-- | ', a.length - 1) + "--\n"

        return table + "\n"

    br_example:
      filter: tag_and_class 'br', 'example-break'
      replacement: (m, n, o)-> ''

    production:
      filter: (n, o)->
        n.nodeName == 'TR' and
        n.firstChild.getAttribute('class') == 'productioncounter'
      replacement: (m, n, o)->
        num = n.getElementsByClassName('productioncounter')[0].textContent
        lhs = n.getElementsByClassName('productionlhs')[0].textContent
        op  = n.getElementsByClassName('productionseperator')[0].textContent
        a = []
        getTexts(n.getElementsByClassName('productionrhs')[0], a)
        rhs = a.join ''
        if rhs.match /\ /
          rhs = "\n  #{rhs}"
        else
          op += ' '

        rhs = rhs.replace /\s+$/, ''

        return """
        ```
        #{num} #{lhs} #{op}#{rhs}
        ```\n\n
        """

    img:
      filter: 'img'
      replacement: (m, n, o)->
        img = n._attrsByQName.src.data
        alt = n._attrsByQName.alt.data
        return "![#{alt}](img/#{img})"

    pre:
      filter: 'pre'
      replacement: (m, n, o)->
        pre = m
          .replace(/^\\/gm, '')
          .replace(/\\([\[\]\*])/g, '$1')
          .replace(/\ +$/mg, '')
        return """
        ```
        #{pre}
        ```\n\n
        """

    p:
      filter: 'p'
      replacement: (m, n, o)->
        return reformat_para(m) + "\n\n"

    dd:
      filter: 'dd'
      replacement: (m, n, o)->
        return reformat_para(m) + "\n\n"

    code:
      filter: 'code'
      replacement: (m, n, o)->
        if m.match /^<.*mailto/
          return m
        else
          return "`#{m}`"

    xxx:
      filter: 'xxx'
      replacement: (m, n, o)->
        skip = [
          'parentNode'
          'ownerDocument'
          '_nextSibling'
          '_previousSibling'
          '_attributeChangeHandlers'
        ]
        x = {}
        for k, v of n
          continue if k in skip
          x[k] = v
        www [m, x]
        xxx 42 if count++ > 10
        return


main = (spec)->
  to_markdown = new HtmlToMarkdown

  html = file_read spec

  out to_markdown.convert html


main process.argv[2..]...
