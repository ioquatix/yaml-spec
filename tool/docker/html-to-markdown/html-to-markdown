#!/usr/bin/env coffee

require 'ingy-prelude'
Turndown = require 'turndown'
Node = require 'domino/lib/Node'
wrap = require 'smartwrap'

count = 0

tag_and_class = (tag, class_)->
  (n, o)->
    n.nodeName == tag.toUpperCase() and
    n.getAttribute('class') == class_

getTexts = (node, a)->
  if node.nodeType == Node.TEXT_NODE
    a.push node._data
  else if node.nodeName == 'BR'
    a.push "\n  "
  else
    for n in node.childNodes
      getTexts n, a

getRowData = (tr)->
  a = []
  for td in tr.childNodes
    a.push _.trim(td.textContent) || ' '
  return a

reformat = (text)->
  width = 79
  out = reformat_para text, width

reformat_para = (text, width)->
  text = text.replace /\ \ $/mg, '%%%'
  text = text.replace ///
      ([\s\S]+?)
      (?:
        (\.)\ (?=[A-Z])
      |
        $
      )
    ///g,
    (x, s, e='')->
      wrap(s, width: width) + "#{e}\n"
  text = text.replace /%%%$/mg, '  '
  return text


class HtmlToMarkdown
  constructor: ->
    @turndown = new Turndown
      headingStyle: 'atx'
      preformattedCode: true
      codeBlockStyle: 'fenced'
      linkStyle: 'inlined'
      hr: '----'

    for k, v of @constructor.rules
      @turndown.addRule k, v

  convert: (html)->
    html = html.replace(/[“”]/g, '"')

    markdown = @turndown.turndown html
      .replace(/.*\n.*\n/, '')
      .replace(/^(###.*)\n\n</gm, '$1 <')
      .replace(/"""/g, "'\"'")
      .replace(/^  $/mg, '')
      .replace(/  \n/g, '')
      .replace(/\n\n\n+/g, "\n\n")
      .replace(/^> $/mg, '>')
      .replace(/^\d\.\ +/mg, '1. ')

    return markdown + "\n"

  @H:
    H1: '#'
    H2: '##'
    H3: '###'
    H4: '####'

  @rules:
    titlepage:
      filter: (n, o)->
        n.nodeName.match(/^H[1-4]$/) and
        n.getAttribute('class') == 'title'
      replacement: (m, n, o)->
        return "# #{m}" unless m.match /\d+\.\s/
        text = m.replace(/(\d+\.)+/, '#.')
        name = n.nodeName
        mark = HtmlToMarkdown.H[name]
        return "#{mark} #{text}"

    link:
      filter: tag_and_class 'a', 'link'
      replacement: (m, n, o)->
        return "[#{m}](#)"

    index:
      filter: tag_and_class 'div', 'index'
      replacement: (m, n, o)->
        return "::index\n"

    releaseinfo:
      filter: tag_and_class 'p', 'releaseinfo'
      replacement: (m, n, o)->
        return m
          .replace(/^\s+(.*)  $/mg, '* $1')
          .replace(/^_(.*)_  $/m, "**$1**\n")
          .replace(
            /^_(.*)_(.*)  $/m,
            "{:.releaseinfo}\n\n**$1**$2")

    simplelist:
      filter: tag_and_class 'table', 'simplelist'
      replacement: (m, n, o)->
        return m unless m.match /\[\d+\]/
        return m.replace ///^
          [\s\S]*
          (
            ```\n
            [\s\S]+\n
            ```\n
          )
          \s*
          (\S[\s\S]+?\S)
          \s*
        $///,
          (m, m1, m2)->
            """\
            #{reformat m2}
            #{m1}

            """

    subtitle:
      filter: tag_and_class 'h2', 'subtitle'
      replacement: (m, n, o)->
        return """\
          **#{m}**
          """

    authorgroup:
      filter: tag_and_class 'div', 'authorgroup'
      replacement: (m, n, o)->
        text = m
          .replace(/### /g, '* **')
          .replace(/\n\n</g, ' <')
          .replace(/>/g, '>**')
          .replace(/\n\n/g, "\n")
          .replace(/^\s+/, '')
        return """\
          #{text}\
          {:.authorgroup}
          """

    indexdiv:
      filter: tag_and_class 'div', 'indexdiv'
      replacement: (m, n, o)->
        return m.replace /### (.*)/, '**$1**'

    toc:
      filter: tag_and_class 'div', 'toc'
      replacement: (m, n, o)->
        return """\
          **Contents**

          ::toc
          """

    informaltable:
      filter: tag_and_class 'div', 'informaltable'
      replacement: (m, n, o)->
        table = ''
        for tr, i in n.getElementsByTagName 'TR'
          a = getRowData tr
          table += '| ' + a.join(' | ') + "\n"
          if i == 0
            table += '| ' + _.repeat('-- | ', a.length - 1) + "--\n"

        return table + "\n"

    br_example:
      filter: tag_and_class 'br', 'example-break'
      replacement: (m, n, o)-> ''

    production:
      filter: (n, o)->
        n.nodeName == 'TR' and
        n.firstChild.getAttribute('class') == 'productioncounter'
      replacement: (m, n, o)->
        num = n.getElementsByClassName('productioncounter')[0].textContent
        lhs = n.getElementsByClassName('productionlhs')[0].textContent
        op  = n.getElementsByClassName('productionseperator')[0].textContent
        a = []
        getTexts(n.getElementsByClassName('productionrhs')[0], a)
        rhs = a.join ''
        if rhs.match /\ /
          rhs = "\n  #{rhs}"
        else
          op += ' '

        rhs = rhs.replace /\s+$/, ''

        return """
          ```
          #{num} #{lhs} #{op}#{rhs}
          ```\n\n
          """

    legend:
      filter: (n, o)->
        n.nodeName == 'DIV' and
        n.getAttribute('class') == 'example-contents' and
        n.innerHTML.match /Legend:/
      replacement: (m, n, o)->
        text = m.replace /```\n\s*Legend:\n([\s\S]+?)```\n\n/, ''
        legend = RegExp.$1
        text = text
          .replace(/^\s+/, '')
          .replace(/\s+$/, "\n")
          .replace(/([^`])`(?=[^`])/g, '$1')
        legend = legend
          .replace(/^\s+`/, '')
          .replace(/`\s+$/, '')
          .replace(/\s+$/, '')
          .replace(/`\s+/g, "\n")
          .replace(/`/g, '')
          .replace(/^/mg, '> * ')
          .replace(/\[(.+?)\]\(#\)/g, '[$1](#rule-$1)')

        return """
          #{text}
          > **Legend:**
          #{legend}\n\n
          """

    example:
      filter: (n, o)->
        n.nodeName == 'DIV' and
        n.getAttribute('class') == 'example-contents' and
        not n.innerHTML.match /Legend:/
      replacement: (m, n, o)->
        return m
          .replace(/([^`])`(?=[^`])/g, '$1')

    node_comparison:
      filter: (n, o)->
        n.nodeName == 'DIV' and
        n.getAttribute('class') == 'variablelist' and
        n.innerHTML.match /(?:YAML therefore requires|Identity should not)/
      replacement: (m, n, o)->
        text = m
          .replace(/^>\ /mg, '')
          .replace(/^\ +$/mg, '')
        text.replace /^(\*.*\n(?:\S.*\n)+)/mg, (m, m1)->
          m1.replace(/^(?=[^\*])/mg, '  ')

    itemizedlist:
      filter: tag_and_class 'div', 'itemizedlist'
      replacement: (m, n, o)->
        m
          .replace(/^\s+/, '')
          .replace(/^\*   /mg, '* ')
          .replace(/^    /mg, '  ')
          .replace(/\s+$/g, "\n")

    img:
      filter: 'img'
      replacement: (m, n, o)->
        img = n._attrsByQName.src.data
        alt = n._attrsByQName.alt.data
        return "![#{alt}](img/#{img})"

    pre:
      filter: 'pre'
      replacement: (m, n, o)->
        pre = m
          .replace(/^\\/gm, '')
          .replace(/\\([\[\]\*])/g, '$1')
          .replace(/\ +$/mg, '')
          .replace(/\\\\/g, '\\')
          .replace(/\\_/g, '_')
        return """
          ```
          #{pre}
          ```\n\n
          """

    p:
      filter: (n, o)->
        n.nodeName == 'P' and
        n.getAttribute('class') != 'releaseinfo'
      replacement: (m, n, o)->
        return reformat(m) + "\n\n"

    dt:
      filter: 'dt'
      replacement: (m, n, o)->
        text = m
        text = "**#{text.replace(/\s+$/, '')}**" unless text.match /\*\*/
        return "#{text}\n\n"

    dd:
      filter: 'dd'
      replacement: (m, n, o)->
        text = reformat(m)
          .replace(/\n+$/, '')
          .replace(/^/mg, '> ')
        return text + "\n\n"

    code:
      filter: 'code'
      replacement: (m, n, o)->
        if m.match /^<.*mailto/
          return m
        else
          return "`#{m}`"

    xxx:
      filter: 'xxx'
      replacement: (m, n, o)->
        skip = [
          'parentNode'
          'ownerDocument'
          '_nextSibling'
          '_previousSibling'
          '_attributeChangeHandlers'
        ]
        x = {}
        for k, v of n
          continue if k in skip
          x[k] = v
        www [m, x]
        xxx 42 if count++ > 10
        return


main = (spec)->
  to_markdown = new HtmlToMarkdown

  html = file_read spec

  out to_markdown.convert(html)


main process.argv[2..]...
